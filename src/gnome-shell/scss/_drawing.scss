// Drawing mixins

// generic drawing of more complex things

@function _widget_edge($c: $borders_edge) {
  // outer highlight "used" on most widgets
  @return 0 1px $c;
}

// provide font size in rem, with px fallback
@mixin fontsize($size: 24, $base: 16) {
  font-size: round($size) + pt;

  //font-size: ($size / $base) * 1rem;
}

@mixin _shadows($shadow1, $shadow2: none, $shadow3: none, $shadow4: none) {
  // Helper function to stack up to 4 box-shadows;

  @if $shadow4 != none {
    box-shadow: $shadow1, $shadow2, $shadow3, $shadow4;
  }
  @else if $shadow3 != none {
    box-shadow: $shadow1, $shadow2, $shadow3;
  }
  @else if $shadow2 != none {
    box-shadow: $shadow1, $shadow2;
  }
  @else {
    box-shadow: $shadow1;
  }
}

@mixin reset {
  color: $fg_color;
  box-shadow: none;
  border-width: 0px;
  border-color: transparent;
  background-color: transparent;
  background-image: none;
  text-shadow: none;
  icon-shadow: none;
}

// entries

@mixin entry {
  color: $fg_color;
  background-color: $base_color;
  box-shadow: inset 0 0 0 1px $border_color;
  border-radius: 6px;

  &:hover, &:focus {
    box-shadow: inset 0 0 0 2px $primary_color;
  }

  &:insensitive {
    color: if($variant == "light", darken($insensitive_fg_color, 10), $insensitive_fg_color);
    box-shadow: inset 0 0 0 1px $border_color;
  }
}

// buttons

@function _border_color($c) {
  @return darken($c, 25%);
}

// colored buttons want
// the border form the
// base color

@function _text_shadow_color($tc: $fg_color, $bg: $bg_color) {
  //
  // calculate the color of text shadows
  //
  // $tc is the text color
  // $bg is the background color
  //
  $_lbg: lightness($bg) / 100%;

  @if lightness($tc) < 50% {
    @return transparentize(white, 1 - $_lbg / ($_lbg * 1.3));
  }
  @else {
    @return transparentize(black, $_lbg * 0.8);
  }
}

@function _button_hilight_color($c) {
  //
  // calculate the right top hilight color for buttons
  //
  // $c: base color;
  //
  @if lightness($c) > 90% {
    @return white;
  }
  @else if lightness($c) > 80% {
    @return transparentize(white, 0.3);
  }
  @else if lightness($c) > 50% {
    @return transparentize(white, 0.5);
  }
  @else if lightness($c) > 40% {
    @return transparentize(white, 0.7);
  }
  @else {
    @return transparentize(white, 0.9);
  }
}

@mixin _button_text_shadow($tc: $fg_color, $bg: $bg_color) {
  // helper function for the text emboss effect
  // $tc is the optional text color, not the shadow color

  $_shadow: _text_shadow_color($tc, $bg);

  @if variant == "dark" {
    @if lightness($tc) < 50% {
      text-shadow: 0 1px $_shadow;
      icon-shadow: 0 1px $_shadow;
    }
    @else {
      text-shadow: 0 0px $_shadow;
      icon-shadow: 0 0px $_shadow;
    }
  }
}

@mixin button($t, $c: $osd_bg_color, $tc: $fg_color, $slice: 2 2 2 2) {
  // Shell themes seem to operate on a "inherit from Adwaita unless specified otherwise" rule
  // So we're doing a reset to erase any default Adwaita styling
  @include reset;
  @include _button_text_shadow($tc, $c);

  border-image: url("assets/buttons/#{$t}/normal.svg") $slice;

  @each $s in "hover", "active", "insensitive" {
    // loop through each state and load the button asset
    @if $s == "hover" {
      &:hover, &:focus {
        border-image: url("assets/buttons/#{$t}/#{$s}.svg") $slice;
      }
    }
    @else if $t == app-view and $s == "active" or $t == app-view-last-child and $s == "active" {
      &:active, &:checked {
        border-image: url("assets/buttons/#{$t}/#{$s}.svg") $slice;
      }
    }
    @else {
      &:#{$s} {
        border-image: url("assets/buttons/#{$t}/#{$s}.svg") $slice;
      }
    }
  }

  @if $t == insensitive {
    color: $insensitive_fg_color;
  }
}
